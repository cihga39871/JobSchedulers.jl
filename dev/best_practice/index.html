<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Best Practice (Please Read) · JobSchedulers.jl</title><meta name="title" content="Best Practice (Please Read) · JobSchedulers.jl"/><meta property="og:title" content="Best Practice (Please Read) · JobSchedulers.jl"/><meta property="twitter:title" content="Best Practice (Please Read) · JobSchedulers.jl"/><meta name="description" content="Documentation for JobSchedulers.jl."/><meta property="og:description" content="Documentation for JobSchedulers.jl."/><meta property="twitter:description" content="Documentation for JobSchedulers.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JobSchedulers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">Manual</a></li><li><a class="tocitem" href="../use_cases/">Use Cases</a></li><li><a class="tocitem" href="../overhead/">Overhead Benchmark</a></li><li class="is-active"><a class="tocitem" href>Best Practice (Please Read)</a><ul class="internal"><li><a class="tocitem" href="#Multi-threaded-or-single-threaded-Julia-session"><span>Multi-threaded or single-threaded Julia session</span></a></li><li><a class="tocitem" href="#Avoid-simultaneous-use-of-Job-and-other-multi-threaded-methods-using-the-:default-thread-pool"><span>Avoid simultaneous use of <code>Job</code> and other multi-threaded methods using the <code>:default</code> thread pool</span></a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../changelog/">Change Log</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Best Practice (Please Read)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Best Practice (Please Read)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/cihga39871/JobSchedulers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/cihga39871/JobSchedulers.jl/blob/main/docs/src/best_practice.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Best-Practice-(Please-Read)"><a class="docs-heading-anchor" href="#Best-Practice-(Please-Read)">Best Practice (Please Read)</a><a id="Best-Practice-(Please-Read)-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practice-(Please-Read)" title="Permalink"></a></h1><p>In the following sections, we briefly go through a few techniques that can help you understand tricks when using JobSchedulers.</p><h2 id="Multi-threaded-or-single-threaded-Julia-session"><a class="docs-heading-anchor" href="#Multi-threaded-or-single-threaded-Julia-session">Multi-threaded or single-threaded Julia session</a><a id="Multi-threaded-or-single-threaded-Julia-session-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-threaded-or-single-threaded-Julia-session" title="Permalink"></a></h2><p>It is recommended to use JobSchedulers in multi-threaded Julia sessions. </p><p><code>Job</code>s are controlled using a main scheduler task (<code>JobSchedulers.SCHEDULER_TASK[]</code>). This task always binds to thread ID (tid) 1 and does not migrate to other threads. During initiation, JobSchedulers checks available tids in the <strong>default</strong> thread pool. </p><p>If the default thread pool is empty after excluding tid 1, JobSchedulers will use a single-thread mode (<code>JobSchedulers.SINGLE_THREAD_MODE[]::Bool</code>). Otherwise, JobSchedulers will use a multi-thread mode.</p><h3 id="Single-thread-Mode"><a class="docs-heading-anchor" href="#Single-thread-Mode">Single-thread Mode</a><a id="Single-thread-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Single-thread-Mode" title="Permalink"></a></h3><p>The maximum number of CPU is default to the system CPU (<code>Sys.CPU_THREADS</code>). </p><p>All <code>Job</code>s are migratable, and they might yield to other tasks. </p><h3 id="Multi-thread-Mode"><a class="docs-heading-anchor" href="#Multi-thread-Mode">Multi-thread Mode</a><a id="Multi-thread-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-thread-Mode" title="Permalink"></a></h3><p>The maximum number of CPU is default to</p><ul><li><p>number of threads in the default thread pool, if you use any interactive threads. (ie. starting julia with <code>-t 10,1</code>.)</p></li><li><p>number of threads in the default thread pool <strong>minus 1</strong>, if you do not use interactive threads. (ie. starting julia with <code>-t 10</code>.)</p></li></ul><p>The tids that JobScheduler.jl can use are stored in a Channel <code>JobSchedulers.THREAD_POOL[]</code>. </p><p>If you submit a job assigning <code>ncpu &gt; 0</code>,</p><ul><li><p>the job takes a thread from <code>THREAD_POOL</code>;</p></li><li><p><strong>the job does not migrate to other threads;</strong> </p></li><li><p>also, if you only use JobSchedulers to schedule tasks, <strong>your tasks will not be blocked by other tasks at any time</strong>. It is important when your tasks need quick response (like a web API server). Therefore, you can ignore the existance of interactive threads when using JobSchedulers.jl.</p><div class="admonition is-info" id="Info-c77fb73c7f59abec"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-c77fb73c7f59abec" title="Permalink"></a></header><div class="admonition-body"><p>JobSchedulers.jl even solves the issue of interactive tasks prior to the official Julia introducing task migration (partially solved) and the interactive/default thread pools.</p></div></div></li></ul><p>If you set <code>ncpu = 0</code> to your job,</p><ul><li><p>the job is migratable and does not take any tid from <code>JobSchedulers.THREAD_POOL[]</code>.</p><div class="admonition is-success" id="Tip-6ed74df134fb0abc"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-6ed74df134fb0abc" title="Permalink"></a></header><div class="admonition-body"><p>Use <code>ncpu = 0</code> only when a job is very small, or a job that spawns and waits for other jobs:</p><pre><code class="language-julia hljs">using JobSchedulers

small_job = Job(ncpu = 0) do
    # within the small job,
    # submit 100 big jobs
    big_jobs = map(1:100) do _
        @submit ncpu=1 sum(rand(9999999))
    end
    # post-process of big jobs
    total = 0.0
    for j in big_jobs
        total += fetch(j)
    end
    total
end
submit!(small_job)
total = fetch(small_job)
# 4.999998913757924e8</code></pre></div></div></li></ul><h4 id="submit-child-jobs"><a class="docs-heading-anchor" href="#submit-child-jobs">Submitting child jobs within a parent job</a><a id="submit-child-jobs-1"></a><a class="docs-heading-anchor-permalink" href="#submit-child-jobs" title="Permalink"></a></h4><p>Submitting jobs within jobs is allowed in JobSchedulers, but it might waste threads and even block the scheduler.</p><p>To prevent the side effects, it is always recommended to use <a href="../API/#JobSchedulers.@yield_current"><code>@yield_current</code></a> to wrap the code that creats and waits for child jobs.</p><p>Why and when do the side effects happen?</p><p>Each job with <code>ncpu &gt; 0</code> takes a unique thread ID when started, and if a parent job submits and waits for a child job during its execution, the thread taken by the parent is wasted when waiting. In a worse senario, if there is no Available thread, the child job won&#39;t start, resulting a scheduler blockage. </p><details class="admonition is-details" id="An-example-to-demonstrate-the-blockage-7ba8e9719fe33d3d"><summary class="admonition-header">An example to demonstrate the blockage<a class="admonition-anchor" href="#An-example-to-demonstrate-the-blockage-7ba8e9719fe33d3d" title="Permalink"></a></summary><div class="admonition-body"><p>Start Julia with 1 interactive and 1 default thread: <code>julia -t 1,1</code>, and run the following code:</p><pre><code class="language-julia hljs">using JobSchedulers

@assert length(JobSchedulers.TIDS) == 1 &quot;Please run the code with `julia -t 1,1`&quot;

parent_job = submit!(@task begin
    println(&quot;Parent job running on thread &quot;, Threads.threadid())

    println(&quot;Available threads in the thread pool: &quot;, JobSchedulers.THREAD_POOL[].data)

    child_job1 = Job(@task begin
        println(&quot;Child job 1 running on thread &quot;, Threads.threadid())
    end; name=&quot;child 1&quot;)
    child_job2 = Job(@task begin
        println(&quot;Child job 2 running on thread &quot;, Threads.threadid())
    end; name=&quot;child 1&quot;)
    
    submit!(child_job1)
    submit!(child_job2)
    
    wait(child_job1)
    wait(child_job2)
end; name=&quot;parent&quot;);
# Parent job running on thread 2
# Available threads in the thread pool: Int64[]

sleep(1)
queue()
# ┌─────┬──────────┬──────────────────┬───────────┬──────┬──────┬─────┬──────────┬───
# │ Row │    state │               id │      name │ user │ ncpu │ mem │ priority │  ⋯
# ├─────┼──────────┼──────────────────┼───────────┼──────┼──────┼─────┼──────────┼───
# │   1 │ :running │ 9386485380519246 │  &quot;parent&quot; │   &quot;&quot; │  1.0 │ 0 B │       20 │  ⋯
# │   2 │ :queuing │ 9386485380548364 │ &quot;child 1&quot; │   &quot;&quot; │  1.0 │ 0 B │       20 │  ⋯
# │   3 │ :queuing │ 9386485380578205 │ &quot;child 1&quot; │   &quot;&quot; │  1.0 │ 0 B │       20 │  ⋯
# └─────┴──────────┴──────────────────┴───────────┴──────┴──────┴─────┴──────────┴───
fetch(parent_job)</code></pre><p>As it shows, the two child jobs is queuing because no Available thread in the thread pool. The scheduler is blocked forever until you kill the parent job (or the Julia session, of course).</p><p>If you do not wait for child jobs, the program will not block, but what if you need the results of child jobs in the parent?</p></div></details><p>To solve it, you can simply wrap child jobs within <a href="../API/#JobSchedulers.@yield_current"><code>@yield_current</code></a> block, like the following example.</p><p>Start Julia with 1 interactive and 1 default thread: <code>julia -t 1,1</code>, and run the following code:</p><pre><code class="language-julia hljs">using JobSchedulers

@assert length(JobSchedulers.TIDS) == 1 &quot;Please run the code with `julia -t 1,1`&quot;
@assert length(queue()) == 0 &quot;Please start a new Julia session: `julia -t 1,1`&quot;

parent_job = submit!(@task begin
    println(&quot;Parent job running on thread &quot;, Threads.threadid())

    println(&quot;Available threads in the thread pool: &quot;, JobSchedulers.THREAD_POOL[].data)

    @yield_current begin
        child_job1 = Job(@task begin
            println(&quot;Child job 1 running on thread &quot;, Threads.threadid())
        end; name=&quot;child 1&quot;)
        child_job2 = Job(@task begin
            println(&quot;Child job 2 running on thread &quot;, Threads.threadid())
        end; name=&quot;child 1&quot;)
        
        submit!(child_job1)
        submit!(child_job2)
        
        wait(child_job1)
        wait(child_job2)
    end
end; name=&quot;parent&quot;);
# Parent job running on thread 2
# Available threads in the thread pool: Int64[]
# Child job 1 running on thread 2
# Child job 2 running on thread 2

fetch(parent_job)</code></pre><p>With <a href="../API/#JobSchedulers.@yield_current"><code>@yield_current</code></a>, the child jobs run successfully with the same thread as its parent, because the parent was yielding to the children.</p><p>More details in <a href="../API/#JobSchedulers.@yield_current"><code>@yield_current</code></a>.</p><h2 id="Avoid-simultaneous-use-of-Job-and-other-multi-threaded-methods-using-the-:default-thread-pool"><a class="docs-heading-anchor" href="#Avoid-simultaneous-use-of-Job-and-other-multi-threaded-methods-using-the-:default-thread-pool">Avoid simultaneous use of <code>Job</code> and other multi-threaded methods using the <code>:default</code> thread pool</a><a id="Avoid-simultaneous-use-of-Job-and-other-multi-threaded-methods-using-the-:default-thread-pool-1"></a><a class="docs-heading-anchor-permalink" href="#Avoid-simultaneous-use-of-Job-and-other-multi-threaded-methods-using-the-:default-thread-pool" title="Permalink"></a></h2><p>Since a normal <code>Job</code> binds to a tid in the default thread pool and does not migrate, it is better not to simultaneously use <code>Job</code> and other threaded methods, such as <code>Threads.@spawn</code> and <code>Threads.@threads</code>. </p><p>Also, JobScheduers has very low computational costs (1~2 us/job from creation to destroy), so normal threaded methods can be replaced with <code>Job</code>.</p><p>If you really want to use both <code>Job</code> and other threaded methods, it is better to make sure to run them at different time. You may use <code>wait_queue()</code>, <code>scheduler_stop()</code>, and <code>scheduler_start()</code> in this situation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overhead/">« Overhead Benchmark</a><a class="docs-footer-nextpage" href="../API/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 5 September 2025 03:07">Friday 5 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
