var documenterSearchIndex = {"docs":
[{"location":"changelog/#Changelog","page":"Change Log","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.8.2","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feat: not replace Base.istaskfailed. Use istaskfailed2 instead.\nFeat: recurring job: job does not immediately after submit, except manually set Job(..., schedule_time). (#8)\nFeat: no double printing stacktrace when a job failed. \nFeat: progress bar: dim job count == 0. (#9)","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.8.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: scheduler() handles errors and InteruptExceptions more wisely. (Thanks to @fivegrant, #7)","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.8.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feat: ncpu == 0 can set to a Job, but a warning message shows.\nFeat: dependency = DONE => job_A: to be simplified to dependency = job_A or dependency = job_A.id.\nFeat: Simplify Job() methods.\nFeat: submit!(Job(...)): to be simplified to submit!(...).\nFeat: schedule repetitive jobs using Cron until a specific date and time: Job(cron = Cron(0,0,*,*,*,*), until = Year(1)). It is  inspired by Linux-based crontab.\nChange: Job(): default wall time value increase to Year(1) from Week(1).\nChange: SCHEDULER_TASK is now a Base.RefValue{Task} rather than undefined or Task.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.12","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Pipelines v0.9, 0.10 (new), 1 (not published).\nDocs: Use Documenter.jl.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.11","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Update: Term to v2.\nFeat: Set a lower loop interval of nthreads > 2.\nFeat: Move scheduler_start() in __init__().","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.10","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Better progress bar for visualization.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.9","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: solve_optimized_ncpu(): devision by 0 if njob == 0.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.8","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: solve_optimized_ncpu(): Find the optimized number of CPU for a job.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.7","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: style_line(): index error for special UTF characters.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.6","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: if original stdout is a file, not contaminating stdout using wait_queue(show_progress = true).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.5","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Change: remove extra blank lines after wait_queue(show_progress = true).\nFix a benign error (task switch error for sleep()).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.4","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Progress meter: wait_queue(show_progress = true).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.3","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Pipelines v0.9: significant improvement on decision of re-run: considering file change.\nFix: pretty print of Job and Vector{Job}.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.2","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: unexpected output of scheduler_status() when SCHEDULER_TASK is not defined.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: PrettyTables = \"0.12 - 2\" to satisfy DataFrames v1.3.5 which needs PrettyTables v1 but not v2.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Remove dependency DataFrames and change to PrettyTables. The loading time of DataFrames is high.\nFeature: now a Job is sticky to one thread (>1). JobSchedulers allocates and manuages it. The SCHEDULER_TASK is sticky to thread 1.\nFeature: queue(...) is rewritten.\nFeature: Better pretty print of Job and queue().\nFeature: New function: wait_queue() waits for all jobs in queue() become finished.\nFeature: New function: set_scheduler()\nFix: set_scheduler_max_cpu(percent::Float64): use default_ncpu() if error.\nChange: SCHEDULERUPDATESECOND to 0.05 from 0.6","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.12","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Enchance compatibility with Pipelines v0.8.5: Program has a new field called arg_forward that is used to forward user-defined inputs/outputs to specific keyword arguments of JobSchedulers.Job(::Program, ...), including name::String, user::String, ncpu::Int, mem::Int.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.11","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: running queue() when updating queue: use lock within DataFrames.DataFrame(job_queue::Vector{Job}).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.10","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Update documents.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.9","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Support Pipelines.jl v0.8.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.8","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Replace @Job with Job to run program without creating inputs::Dict and outputs::Dict. Remove @Job.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.7","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Run program without creating inputs::Dict and outputs::Dict: @Job program::Program key_value_args... Job_args.... See also @run in Pipelines.jl.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.6","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: job.dependency now accepts DONE => job, [DONE => job1.id; PAST => job2].\nOptimize: is_dependency_ok(job::Job)::Bool is rewritten: for loop when found a dep not ok, and delete previous ok deps. If dep is provided as Int, query Int for job and then replace Int with the job.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.5","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: If an app is built, SCHEDULERMAXCPU and SCHEDULERMAXMEM will be fixed to the building computer: fix by re-defining SCHEDULER_MAX_CPU and SCHEDULER_MAX_MEM in __init__().\nDebug: add debug outputs.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.4","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: scheduler_stop() cannot stop because v0.6.1 update. Now scheduler_stop does not send ^C to SCHEDULER_TASK, but a new global variable SCHEDULER_WHILE_LOOP::Bool is added to control the while loop in scheduler().\nOptimize: the package now can be precompiled: global Task cannot be precompiled, so we do not define SCHEDULER_TASK::Task when loading the package. Define it only when needed.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.3","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: scheduler_start() now wait until SCHEDULER_TASK is actually started. Previously, it returns after schedule(SCHEDULER_TASK).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.2","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat Pipelines v0.7.0.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Robustness: scheduler() and waitforlock(): wrap sleep() within a try-catch block. If someone sends ctrl + C to sleep, scheduler wont stop.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compatibility: Pipelines v0.5.0: Job(...; dir=dir).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.5.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: programcloseio: If the current stdout/stderr is IO, restore to default stdout/stderr.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.5.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compatibility: Pipelines v0.5.0: fixed redirection error and optimized stack trace display. Extend Base.istaskfailed to fit Pipelines and JobSchedulers packages, which will return a StackTraceVector in t.result, while Base considered it as :done. The fix checks the situation and modifies the real task status and other properties.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.4.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Export PAST. PAST is the super set of DONE, FAILED, CANCELLED, which means the job will not run in the future.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.4.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"If running with multi-threads Julia, SCHEDULER_TASK runs in thread 1, and other jobs spawn at other threads. Thread assignment was achieved by JobScheduler. Besides, SCHEDULER_MAX_CPU = nthreads() > 1 ? nthreads()-1 : Sys.CPU_THREADS.\nNew feature: queue(job_state::Symbol).\nUse try-finally for all locks.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.3.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Tasks run on different threads, if Julia version supports and nthreads() > 1.\nUse SpinLock.\nFix typo \"queuing\" from \"queueing\".\nNotify when a job is failed.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you need to run multiple heavy Julia tasks, it is recommended to start Julia with multi-threads.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JobSchedulers, Dates","category":"page"},{"location":"manual/#Scheduler-control","page":"Manual","title":"Scheduler control","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"scheduler_stop()\n# [ Info: Scheduler stops.\n\nscheduler_start()\n# ┌ Warning: Scheduler was interrupted or done. Restart.\n# └ @ JobSchedulers ~/projects/JobSchedulers.jl/src/control.jl:38\n\nscheduler_status()\n# ┌ Info: Scheduler is running.\n# │   SCHEDULER_MAX_CPU = 32\n# │   SCHEDULER_MAX_MEM = 121278191616\n# │   SCHEDULER_UPDATE_SECOND = 0.05\n# │   JOB_QUEUE_MAX_LENGTH = 10000\n# └   SCHEDULER_TASK = Task (runnable) @0x00007fe205052e60\n# :running\n","category":"page"},{"location":"manual/#Scheduler-settings","page":"Manual","title":"Scheduler settings","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the maximum CPU that the scheduler can use. If starting Julia with multi-threads, the maximum CPU is nthreads() - 1.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_max_cpu()     # use all available CPUs\n# 32\nset_scheduler_max_cpu(4)    # use 4 CPUs\n# 4\nset_scheduler_max_cpu(0.5)  # use 50% of CPUs\n# 16","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the maximum RAM the scheduler can use:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_max_mem()             # use 80% of total memory\n# 107792089088\n\nset_scheduler_max_mem(4GB)          # use 4GB memory\nset_scheduler_max_mem(4096MB)\nset_scheduler_max_mem(4194304KB)\nset_scheduler_max_mem(4294967296B)\n# 4294967296\nset_scheduler_max_mem(0.5)          # use 50% of total memory\n# 67370055680","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the update interval of job queue:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_update_second(0.03)  # update job queue every 0.3 seconds\n# 0.03","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the maximum number of finished jobs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_max_job(10000)  # If number of finished jobs > 10000, the oldest ones will be removed.\n# 10000                       # It does not affect queuing or running jobs.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the previous setting in one function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler(\n    max_cpu = JobSchedulers.SCHEDULER_MAX_CPU,\n    max_mem = JobSchedulers.SCHEDULER_MAX_MEM,\n    update_second = JobSchedulers.SCHEDULER_UPDATE_SECOND,\n    max_job = JobSchedulers.JOB_QUEUE_MAX_LENGTH\n)\n# ┌ Info: Scheduler is running.\n# │   SCHEDULER_MAX_CPU = 16\n# │   SCHEDULER_MAX_MEM = 67370055680\n# │   SCHEDULER_UPDATE_SECOND = 0.03\n# │   JOB_QUEUE_MAX_LENGTH = 10000\n# └   SCHEDULER_TASK = Task (runnable) @0x00007fd239184fe0\n# :running","category":"page"},{"location":"manual/#Create-a-Job","page":"Manual","title":"Create a Job","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Job is the wrapper of AbstractCmd, Function or Task:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"command_job = Job(\n    `echo command job done`    # AbstractCmd to run\n)\n\nfunction_job = Job() do  # the function should have no arguments\n    println(\"function job done\")\nend\n\ntask_job = Job(\n    @task(println(\"task job done\"))  # Task to run\n)\n\njob_with_args = Job(\n    @task(begin println(\"job_with_args done\"); \"result\" end); # Task to run\n    name = \"job with args\",               # job name.\n    user = \"me\",                # Job owner.\n    ncpu = 1,                   # Number of CPU required.\n    mem = 1KB,                  # Number of memory required (unit: TB, GB, MB, KB, B).\n    schedule_time = Second(3),  # Run after 3 seconds; can be ::DateTime or ::Period.\n    wall_time = Hour(1),        # The maximum time to run the job. (Cancel job after reaching wall time.)\n    priority = 20,              # Lower number = higher priority.\n    dependency = [              # Defer job until some jobs reach some states.\n        command_job,\n        DONE => task_job\n    ]\n)\n# Job:\n#   id            → 4645128769531704\n#   name          → \"job with args\"\n#   user          → \"me\"\n#   ncpu          → 1\n#   mem           → 1024\n#   schedule_time → 2023-05-21 08:37:23\n#   create_time   → 0000-01-01 00:00:00\n#   start_time    → 0000-01-01 00:00:00\n#   stop_time     → 0000-01-01 00:00:00\n#   wall_time     → 1 hour\n#   cron          → Cron(:none)\n#   until         → 9999-01-01 00:00:00\n#   state         → :queuing\n#   priority      → 20\n#   dependency    → 2 jobs\n#   task          → Task\n#   stdout_file   → \"\"\n#   stderr_file   → \"\"\n#   _thread_id    → 0\n#   _func         → #12","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"dependency argument in Job(...) controls when to start a job.It is a vector with element STATE => job or STATE => job.id.STATE is one of DONE, FAILED, CANCELLED, QUEUING, RUNNING, PAST.   The first 5 states are real job states.   PAST is the super set of DONE, FAILED, CANCELLED, which means the job will not run in the future.DONE => job can be simplified to job from v0.8.","category":"page"},{"location":"manual/#Submit-a-Job","page":"Manual","title":"Submit a Job","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Submit a job to queue:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"submit!(command_job)\nsubmit!(task_job)\nsubmit!(job_with_args)\n\n# submit!(Job(...)) can be simplified to submit!(...) (from v0.8)\njob = submit!(@task(println(\"job\")), priority = 0)","category":"page"},{"location":"manual/#Cancel-a-Job","page":"Manual","title":"Cancel a Job","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Cancel or interrupt a job:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"cancel!(command_job)","category":"page"},{"location":"manual/#Get-a-Job's-Result","page":"Manual","title":"Get a Job's Result","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Get the returned result:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"result(job_with_args)\n# \"result\"","category":"page"},{"location":"manual/#Recurring/repetitive-Job","page":"Manual","title":"Recurring/repetitive Job","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"From JobSchedulers v0.8, users can submit recurring jobs using Linux-based Crontab-like methods.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Two new fields (arguments) of Job is introduced: Job(cron::Cron, until::Union{DateTime,Period}).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"cron::Cron creates a Cron object. It extends Linux's crontab and allows repeat every XX seconds. You can use your favorate *, -, , syntax just like crontab. Other features please see Cron.\nuntil::Union{DateTime,Period}): stop job recurring until date and time.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Construction:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Cron(second, minute, hour, day_of_month, month, day_of_week)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Examples:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Cron()\n# Cron(every minute at 0 second)\n\nCron(0,0,0,1,1,0)\nCron(:yearly)\nCron(:annually)\n# Cron(at 0:0:0 on day-of-month 1 in Jan)\n\nCron(0,0,0,1,*,*)\nCron(:monthly)\n# Cron(at 0:0:0 on day-of-month 1)\n\nCron(0,0,0,*,*,1)\nCron(:weekly)\n# Cron(at 0:0:0 on Mon)\n\nCron(0,0,0,*,'*',\"*\") # * is equivalent to '*', and \"*\" in Cron.\nCron(:daily)\nCron(:midnight)\n# Cron(at 0:0:0)\n\nCron(0,0,*,*,*,*)\nCron(:hourly)\n# Cron(at 0 minute, 0 second)\n\nCron(0,0,0,0,0,0) # never repeat\nCron(:none)       # never repeat\n# Cron(:none)\n\nCron(0,0,0,*,*,\"*/2\")\n# Cron(at 0:0:0 on Tue,Thu,Sat)\n\nCron(0,0,0,*,*,\"1-7/2\")\nCron(0,0,0,0,0,\"1-7/2\")\n# Cron(at 0:0:0 on Mon,Wed,Fri,Sun)\n\nCron(0,0,0,1,\"1-12/3\",*)\n# Cron(at 0:0:0 on day-of-month 1 in Jan,Apr,Jul,Oct)\n\nCron(30,4,\"1,3-5\",1,*,*)\n# Cron(at 4 minute, 30 second past 1,3,4,5 hours on day-of-month 1)\n\n# repeatly print time every 5 seconds, until current time plus 20 seconds\nrecurring_job = submit!(cron = Cron(\"*/5\", *, *, *, *, *), until = Second(20)) do\n    println(now())\nend\n# 2023-05-21T09:22:12.568\n# 2023-05-21T09:22:15.055\n# 2023-05-21T09:22:20.005\n# 2023-05-21T09:22:25.022\n# 2023-05-21T09:22:30.037","category":"page"},{"location":"manual/#Queue","page":"Manual","title":"Queue","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Show all jobs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue(:all)      # or:\nqueue(all=true)  # or:\nall_queue()\n# 3-element Vector{Job}:\n# ┌─────┬───────┬──────────────────┬─────────────────┬──────┬──────┬────────\n# │ Row │ state │               id │            name │ user │ ncpu │  mem  ⋯\n# ├─────┼───────┼──────────────────┼─────────────────┼──────┼──────┼────────\n# │   1 │ :done │ 3603962559801309 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   2 │ :done │ 3603962563817452 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   3 │ :done │ 3603962603799412 │ \"job with args\" │ \"me\" │    1 │ 1024  ⋯\n# └─────┴───────┴──────────────────┴─────────────────┴──────┴──────┴────────\n#                                                         11 columns omitted","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Show queue (running and queuing jobs only):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue()\n# 0-element Vector{Job}:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Show queue using a job state (QUEUING, RUNNING, DONE, FAILED, CANCELLED, or PAST):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue(DONE)\n# 3-element Vector{Job}:\n# ┌─────┬───────┬──────────────────┬─────────────────┬──────┬──────┬────────\n# │ Row │ state │               id │            name │ user │ ncpu │  mem  ⋯\n# ├─────┼───────┼──────────────────┼─────────────────┼──────┼──────┼────────\n# │   1 │ :done │ 3603962559801309 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   2 │ :done │ 3603962563817452 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   3 │ :done │ 3603962603799412 │ \"job with args\" │ \"me\" │    1 │ 1024  ⋯\n# └─────┴───────┴──────────────────┴─────────────────┴──────┴──────┴────────\n#                                                         11 columns omitted","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue(...) and all_queue() can also used to filter job name and user.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"See more at queue, and all_queue.","category":"page"},{"location":"manual/#Job-query","page":"Manual","title":"Job query","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Get Job object by providing job ID, or access the index of queue:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"job_query(4645344816210967)  # or:\nqueue(4645344816210967)\nqueue(:all)[1]\n# Job:\n#   id            → 4645344816210967\n#   name          → \"\"\n#   user          → \"\"\n#   ncpu          → 1\n#   mem           → 0\n#   schedule_time → 0000-01-01 00:00:00\n#   create_time   → 2023-05-21 09:32:24\n#   start_time    → 2023-05-21 09:32:24\n#   stop_time     → 2023-05-21 09:32:25\n#   wall_time     → 1 year\n#   cron          → Cron(:none)\n#   until         → 9999-01-01 00:00:00\n#   state         → :done\n#   priority      → 20\n#   dependency    → []\n#   task          → Task\n#   stdout_file   → \"\"\n#   stderr_file   → \"\"\n#   _thread_id    → 0\n#   _func         → #22","category":"page"},{"location":"manual/#Wait-for-jobs-and-progress-meter","page":"Manual","title":"Wait for jobs and progress meter","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Wait for jobs finished using wait_queue.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"wait_queue()\n# no output\n\n# If `show_progress = true`, a fancy progress meter will display.\nwait_queue(show_progress = true)\n\n# stop waiting when <= 2 jobs are queuing or running.\nwait_queue(show_progress = true, exit_num_jobs = 2)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(Image: progress meter)","category":"page"},{"location":"manual/#Find-optimized-ncpu-that-a-Job-can-use","page":"Manual","title":"Find optimized ncpu that a Job can use","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Only available from JobSchedulers v0.7.8.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"solve_optimized_ncpu(default::Int; \n    ncpu_range::UnitRange{Int64} = 1:total_cpu, \n    njob::Int = 1, \n    total_cpu::Int = JobSchedulers.SCHEDULER_MAX_CPU, \n    side_jobs_cpu::Int = 0)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Find the optimized number of CPU for a job.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"default: default ncpu of the job.\nncpu_range: the possible ncpu range of the job.\nnjob: number of the same job.\ntotal_cpu: the total CPU that can be used by JobSchedulers.\nside_jobs_cpu: some small jobs that might be run when the job is running, so the job won't use up all of the resources and stop small tasks.","category":"page"},{"location":"manual/#Compatibility-with-Pipelines.jl","page":"Manual","title":"Compatibility with Pipelines.jl","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Pipelines.jl: A lightweight Julia package for computational pipelines and workflows.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can also create a Job by using Program types from Pipelines.jl:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Job(p::Program; program_kwargs..., run_kwargs..., job_kwargs...)\nJob(p::Program, inputs; run_kwargs..., job_kwargs...)\nJob(p::Program, inputs, outputs; run_kwargs..., job_kwargs...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"program_kwargs... is input and output arguments defined in p::Program.\nrun_kwargs... is keyword arguments of run(::Program; ...)\njob_kwargs... is keyword arguments of Job(::Union{Base.AbstractCmd,Task}; ...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Details can be found by typing","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using Pipelines, JobSchedulers\njulia> ?run\njulia> ?Job","category":"page"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Pipelines, JobSchedulers\n\nscheduler_start()\n\np = CmdProgram(\n    inputs = [\"IN1\", \"IN2\"],\n    outputs = \"OUT\",\n    cmd = pipeline(`echo inputs are: IN1 and IN2` & `echo outputs are: OUT`)\n)\n# CmdProgram:\n#   name             → Command Program\n#   id_file          → \n#   info_before      → auto\n#   info_after       → auto\n#   cmd_dependencies → CmdDependency[]\n#   arg_inputs       → IN1 :: Any (required)\n#                      IN2 :: Any (required)\n#   validate_inputs  → do_nothing\n#   prerequisites    → do_nothing\n#   cmd              → `echo inputs are: IN1 and IN2` & `echo outputs are: OUT`\n#   infer_outputs    → do_nothing\n#   arg_outputs      → OUT :: Any (required)\n#   validate_outputs → do_nothing\n#   wrap_up          → do_nothing\n#   arg_forward      → Pair{String, Symbol}[]\n\n\n### native Pipelines.jl method to run the program\nrun(p, IN1 = `in1`, IN2 = 2, OUT = \"out\", touch_run_id_file = false) # touch_run_id_file = false means do not create a file which indicates the job is done and avoids re-run.\n\n# inputs are: in1 and in2\n# outputs are: out\n# (true, Dict(\"OUT\" => \"out\"))\n\n### run the program by submitting to JobSchedulers.jl\nprogram_job = Job(p, IN1 = `in1`, IN2 = 2, OUT = \"out\", touch_run_id_file = false)\n# Job:\n#   id            → 3603980229784158\n#   name          → \"Command Program\"\n#   user          → \"\"\n#   ncpu          → 1\n#   mem           → 0\n#   schedule_time → 0000-01-01 00:00:00\n#   create_time   → 0000-01-01 00:00:00\n#   start_time    → 0000-01-01 00:00:00\n#   stop_time     → 0000-01-01 00:00:00\n#   wall_time     → 1 week\n#   state         → :queuing\n#   priority      → 20\n#   dependency    → []\n#   task          → Task\n#   stdout_file   → \"\"\n#   stderr_file   → \"\"\n#   _thread_id    → 0\n\nsubmit!(program_job)\n# inputs are: in1 and 2\n# outputs are: out\n\n# get the returned result\nresult(program_job)\n# (true, Dict(\"OUT\" => \"out\"))","category":"page"},{"location":"manual/#Backup","page":"Manual","title":"Backup","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set backup file:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_backup(\"/path/to/backup/file\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"JobSchedulers writes to the backup file at exit. If the file exists, scheduler settings and job queue will be recovered from it automatically. Recovered jobs are just for query, not run-able.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Stop backup and delete_old backup:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_backup(delete_old=true)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Backup immediately:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"backup()","category":"page"},{"location":"#JobSchedulers.jl","page":"Home","title":"JobSchedulers.jl","text":"","category":"section"},{"location":"#Why-JobScheduler?","page":"Home","title":"Why JobScheduler?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We may find different tasks or programs use different CPU and memory. Some can run simultaneously, but some have to run sequentially. JobScheduler is stable, useful and powerful for task queuing and workload management, inspired by Slurm/PBS and Crontab.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Job and task scheduler.\nLocal workload manager.\nSupport CPU, memory, run time management.\nSupport running a job at specific time, or a period after creating (schedule).\nSupport recurring/repetitive jobs using Cron-like schedule expressions.\nSupport deferring a job until specific jobs reach specific states (dependency).\nSupport automatic backup and reload.\nFancy progress meter in terminal.\n(Image: progress meter)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JobSchedulers.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add JobSchedulers","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JobSchedulers","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Scheduler-Control","page":"API","title":"Scheduler Control","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"scheduler_status\nscheduler_start\nscheduler_stop","category":"page"},{"location":"API/#JobSchedulers.scheduler_status","page":"API","title":"JobSchedulers.scheduler_status","text":"scheduler_status() :: Symbol\n\nPrint the settings and status of job scheduler. Return :not_running or :running.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.scheduler_start","page":"API","title":"JobSchedulers.scheduler_start","text":"scheduler_start()\n\nStart the job scheduler.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.scheduler_stop","page":"API","title":"JobSchedulers.scheduler_stop","text":"scheduler_stop()\n\nStop the job scheduler.\n\n\n\n\n\n","category":"function"},{"location":"API/#Scheduler-Settings","page":"API","title":"Scheduler Settings","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"set_scheduler\nset_scheduler_max_cpu\nset_scheduler_max_mem\nset_scheduler_update_second\nset_scheduler_max_job","category":"page"},{"location":"API/#JobSchedulers.set_scheduler","page":"API","title":"JobSchedulers.set_scheduler","text":"set_scheduler(;\n    max_cpu::Union{Int,Float64} = JobSchedulers.SCHEDULER_MAX_CPU,\n    max_mem::Union{Int,Float64} = JobSchedulers.SCHEDULER_MAX_MEM,\n    max_job::Int = JobSchedulers.JOB_QUEUE_MAX_LENGTH,\n    update_second = JobSchedulers.SCHEDULER_UPDATE_SECOND\n)\n\nSee details: set_scheduler_max_cpu,  set_scheduler_max_mem,  set_scheduler_max_job,  set_scheduler_update_second \n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_max_cpu","page":"API","title":"JobSchedulers.set_scheduler_max_cpu","text":"set_scheduler_max_cpu(ncpu::Int = default_ncpu())\nset_scheduler_max_cpu(percent::Float64)\n\nSet the maximum CPU (thread) the scheduler can use. If starting Julia with multi-threads, the maximum CPU is nthreads() - 1.\n\nExample\n\nset_scheduler_max_cpu()     # use all available CPUs\nset_scheduler_max_cpu(4)    # use 4 CPUs\nset_scheduler_max_cpu(0.5)  # use 50% of CPUs\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_max_mem","page":"API","title":"JobSchedulers.set_scheduler_max_mem","text":"set_scheduler_max_mem(mem::Int = default_mem())\nset_scheduler_max_mem(percent::Float64)\n\nSet the maximum RAM the scheduler can use.\n\nExample\n\nset_scheduler_max_mem()             # use 80% of total memory\n\nset_scheduler_max_mem(4GB)          # use 4GB memory\nset_scheduler_max_mem(4096MB)\nset_scheduler_max_mem(4194304KB)\nset_scheduler_max_mem(4294967296B)\n\nset_scheduler_max_mem(0.5)          # use 50% of total memory\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_update_second","page":"API","title":"JobSchedulers.set_scheduler_update_second","text":"set_scheduler_update_second(s::Float64 = 0.6)\n\nSet the update interval of scheduler.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_max_job","page":"API","title":"JobSchedulers.set_scheduler_max_job","text":"set_scheduler_max_job(n_finished_jobs::Int = 10000)\n\nSet the number of finished jobs.\n\n\n\n\n\n","category":"function"},{"location":"API/#Job","page":"API","title":"Job","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Job\nsubmit!\ncancel!\nresult","category":"page"},{"location":"API/#JobSchedulers.Job","page":"API","title":"JobSchedulers.Job","text":"Job(command::Base.AbstractCmd; stdout=nothing, stderr=nothing, append::Bool=false, kwargs...)\nJob(f::Function; kwargs...)\nJob(task::Task; kwargs...)\n\nArguments\n\ncommand::Base.AbstractCmd: the command to run.\nf::Function: the function to run without any arguments, like f().\ntask::Task: the task to run. Eg: @task(1+1).\n\nCommon Keyword Arguments (kwargs...)\n\nname::String = \"\": job name.\nuser::String = \"\": user that job belongs to.\nncpu::Int64 = 1: number of CPU this job is about to use.\nmem::Int64 = 0: number of memory this job is about to use (supports TB, GB, MB, KB, B=1).\nschedule_time::Union{DateTime,Period} = DateTime(0): The expected time to run.\ndependency: defer job until specified jobs reach specified state (QUEUING, RUNNING, DONE, FAILED, CANCELLED, PAST). PAST is the super set of DONE, FAILED, CANCELLED, which means the job will not run in the future. Eg: DONE => job, [DONE => job1; PAST => job2].\n\nThe default state is DONE, so DONE => job can be simplified to job. To be compatible with old versions, you can also use job id (Int): [DONE => job.id].\n\nwall_time::Period = Year(1): wall clock time limit. Jobs will be terminated after running for this period.\npriority::Int = 20: lower means higher priority.\ncron::Cron = Cron(:none): job recurring at specfic date and time. See more at Cron.\nuntil::Union{DateTime,Period} = DateTime(9999,1,1): stop job recurring until date and time.\n\nExperimental Keyword Arguments - Output Redirection:\n\nstdout=nothing: redirect stdout to the file.\nstderr=nothing: redirect stderr to the file.\nappend::Bool=false: append the stdout or stderr or not.\n\nnote: Note\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks simultaneously (multi-threading).\n\n\n\n\n\n","category":"type"},{"location":"API/#JobSchedulers.submit!","page":"API","title":"JobSchedulers.submit!","text":"submit!(job::Job)\n\nSubmit the job. If job.create_time == 0000-01-01T00:00:00 (default), it will change to the time of submission.\n\nsubmit!(Job(...)) can be simplified to submit!(...). They are equivalent.\n\nSee also Job\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.cancel!","page":"API","title":"JobSchedulers.cancel!","text":"cancel!(job::Job)\n\nCancel job, stop queuing or running.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.result","page":"API","title":"JobSchedulers.result","text":"result(job::Job)\n\nReturn the result of job. If the job is not done, a warning message will also show.\n\n\n\n\n\n","category":"function"},{"location":"API/#Cron:-Job-Recur/Repeat","page":"API","title":"Cron: Job Recur/Repeat","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Cron\nJobSchedulers.cron_value_parse\nDates.tonext(::DateTime, ::Cron)\nJobSchedulers.date_based_on","category":"page"},{"location":"API/#JobSchedulers.Cron","page":"API","title":"JobSchedulers.Cron","text":"Cron(second, minute, hour, day_of_month, month, day_of_week)\nCron(;\n    second = 0,\n    minute = '*',\n    hour = '*',\n    day_of_month = '*',\n    month = '*',\n    day_of_week = '*',\n)\n\nCron stores the schedule of a repeative Job, inspired by Linux-based crontab(5) table.\n\nJobs are executed by JobScheduler when the second, minute, and hour fields match the current time, and when at least one of the two day fields (day of month & month, or day of week) match the current time.\n\nWhen an argument is an Int64:\n\nField Allowed values\nsecond 0-59\nminute 0-59\nhour 0-23\nday_of_month 1-31\nmonth 1-12\nday_of_week 1-7 (1 is Monday)\n\nWhen an argument is a String or Char:\n\nAn argument may be an asterisk (*), which always stands for first-last.\n\nRanges of numbers are allowed. Ranges are two numbers separated with a hyphen. The specified range is inclusive. For example, 8-11 for an hours entry specifies execution at hours 8, 9, 10 and 11.\n\nLists are allowed. A list is a set of numbers (or ranges) separated by commas. Examples: \"1,2,5,9\", \"0-4,8-12\".\n\nStep values can be used in conjunction with ranges. Following a range with /<number> specifies skips of the number's value through the range. For example, \"0-23/2\" can be used in the hour argument to specify Job execution every other hour (the alternative is \"0,2,4,6,8,10,12,14,16,18,20,22\"). Steps are also permitted after an asterisk, so if you want to say every two hours, just use \"*/2\".\n\nWhen an argument is a Vector:\n\nVector works like lists mentioned above. For example, [1,2,5,9] is equivalent to \"1,2,5,9\".\n\nWhen an argument is a UInt64:\n\nUInt64 is the internal type of Cron fileds. All the previous types will be converted to a UInt64 bit array. The start index of the bit array is 0. Bits outside of the allowed values (see the table above) are ignored.\n\n\n\n\n\nCron(special::Symbol)\n\nInstead of the six arguments of Cron, one of the following special symbols may appear instead:\n\nspecial Meaning\n:yearly Run once a year, Cron(0,0,0,1,1,0)\n:annually (same as :yearly)\n:monthly Run once a month, Cron(0,0,0,1,'*','*')\n:weekly Run once a week, Cron(0,0,0,'*','*',1)\n:daily Run once a day, Cron(0,0,0,'*','*','*')\n:midnight (same as :daily)\n:hourly Run once an hour, Cron(0,0,'*','*','*','*')\n:none Never repeat, Cron(0,0,0,0,0,0)\n\nCaution: Linux crontab's special :reboot is not supported here.\n\nTo run every minute, just use Cron().\n\n\n\n\n\n","category":"type"},{"location":"API/#JobSchedulers.cron_value_parse","page":"API","title":"JobSchedulers.cron_value_parse","text":"cron_value_parse(value::UInt64)\ncron_value_parse(value::Int64)\ncron_value_parse(value::String)\ncron_value_parse(value::Char)\ncron_value_parse(value::Vector)\ncron_value_parse(*) = cron_value_parse('*')\n\nParse crontab-like value to UInt64. See details: Cron.\n\n\n\n\n\n","category":"function"},{"location":"API/#Dates.tonext-Tuple{DateTime, Cron}","page":"API","title":"Dates.tonext","text":"Dates.tonext(dt::DateTime, c::Cron) -> Union{DateTime, Nothing}\nDates.tonext(t::Time, c::Cron; same::Bool = false) -> Time\nDates.tonext(d::Date, c::Cron; same::Bool = false) -> Union{DateTime, Nothing}\n\nJobs are executed by JobScheduler when the second, minute, hour, and month of year fields match the current time, and when at least one of the two day fields (day of month, or day of week) match the current time.\n\n\n\n\n\n","category":"method"},{"location":"API/#JobSchedulers.date_based_on","page":"API","title":"JobSchedulers.date_based_on","text":"date_based_on(c::Cron) -> Symbol\n\nWhether date of c is based on :dayofweek, :monthday, :everyday, :both, or :none.\n\n\n\n\n\n","category":"function"},{"location":"API/#Queue","page":"API","title":"Queue","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"queue\nall_queue\njob_query","category":"page"},{"location":"API/#JobSchedulers.queue","page":"API","title":"JobSchedulers.queue","text":"queue(; all::Bool = false)    -> Vector{Job}\nqueue(state::Symbol )         -> Vector{Job}\nqueue(needle)                 -> Vector{Job}\nqueue(state::Symbol , needle) -> Vector{Job}\nqueue(needle, state::Symbol ) -> Vector{Job}\nqueue(id::Int)                -> Job\n\nall::Bool: if true, get all jobs. if false, get only running and queuing jobs.\nstate::Symbol: get jobs with a specific state, including :all, QUEUING, RUNNING, DONE, FAILED, CANCELLED, PAST.\nPAST is the superset of DONE, FAILED, CANCELLED.\nneedle::Union{AbstractString,AbstractPattern,AbstractChar}: get jobs if they contain needle in their name or user.\nid::Int: get the job with the specific id.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.all_queue","page":"API","title":"JobSchedulers.all_queue","text":"all_queue()\nall_queue(id::Int64)\nall_queue(state::Symbol)\nall_queue(needle::Union{AbstractString,AbstractPattern,AbstractChar})\n\nstate::Symbol: get jobs with a specific state, including :all, QUEUING, RUNNING, DONE, FAILED, CANCELLED, PAST.\nPAST is the superset of DONE, FAILED, CANCELLED.\nneedle::Union{AbstractString,AbstractPattern,AbstractChar}: get jobs if they contain needle in their name or user.\nid::Int: get the job with the specific id.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.job_query","page":"API","title":"JobSchedulers.job_query","text":"job_query_by_id(id::Int64)\n\nSearch job by job.id in the queue.\n\nReturn job::Job if found, nothing if not found.\n\n\n\n\n\n","category":"function"},{"location":"API/#Wait-For-Jobs","page":"API","title":"Wait For Jobs","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"wait_queue","category":"page"},{"location":"API/#JobSchedulers.wait_queue","page":"API","title":"JobSchedulers.wait_queue","text":"wait_queue(;show_progress::Bool = false, exit_num_jobs::Int = 0)\n\nWait for all jobs in queue() become finished.\n\nshow_progress = true, job progress will show.\nexit_num_jobs::Int: exit when queue() has less than Int number of jobs. It is useful to ignore some jobs that are always running or recurring.\n\nSee also: queue_progress.\n\n\n\n\n\n","category":"function"},{"location":"API/#Optimize-CPU-Usage","page":"API","title":"Optimize CPU Usage","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"solve_optimized_ncpu","category":"page"},{"location":"API/#JobSchedulers.solve_optimized_ncpu","page":"API","title":"JobSchedulers.solve_optimized_ncpu","text":"solve_optimized_ncpu(default::Int; \n    ncpu_range::UnitRange{Int64} = 1:total_cpu, \n    njob::Int = 1, \n    total_cpu::Int = JobSchedulers.SCHEDULER_MAX_CPU, \n    side_jobs_cpu::Int = 0)\n\nFind the optimized number of CPU for a job.\n\ndefault: default ncpu of the job.\nncpu_range: the possible ncpu range of the job.\nnjob: number of the same job.\ntotal_cpu: the total CPU that can be used by JobSchedulers.\nside_jobs_cpu: some small jobs that might be run when the job is running, so the job won't use up all of the resources and stop small tasks.\n\n\n\n\n\n","category":"function"},{"location":"API/#Backup","page":"API","title":"Backup","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"set_scheduler_backup\nbackup","category":"page"},{"location":"API/#JobSchedulers.set_scheduler_backup","page":"API","title":"JobSchedulers.set_scheduler_backup","text":"set_scheduler_backup(\n    filepath::AbstractString = \"\";\n    migrate::Bool = false,\n    delete_old::Bool = false,\n    recover_settings::Bool = true,\n    recover_queue::Bool = true\n)\n\nSet the backup file of job scheduler.\n\nIf filepath was set to \"\", stop backup at exit.\n\nIf filepath was set to an existing file, recover_settings or recover_queue from filepath immediately.\n\nIf filepath was set to a new file, the backup file will be created at exit.\n\nIf migrate=true and the old JobSchedulers.SCHEDULER_BACKUP_FILE exists, the old backup file will be recovered before recovering from filepath.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.backup","page":"API","title":"JobSchedulers.backup","text":"backup()\n\nManually backup job scheduler settings and queues. The function is automatically triggered at exit.\n\n\n\n\n\n","category":"function"},{"location":"API/#Progress-Meter","page":"API","title":"Progress Meter","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"note: Note\nTo display a progress meter, please use wait_queue(show_progress = true).","category":"page"},{"location":"API/","page":"API","title":"API","text":"JobSchedulers.JobGroup\nJobSchedulers.fingerprint\nJobSchedulers.get_group\nJobSchedulers.progress_bar\nJobSchedulers.queue_progress\nJobSchedulers.view_update","category":"page"},{"location":"API/#JobSchedulers.JobGroup","page":"API","title":"JobSchedulers.JobGroup","text":"mutable struct JobGroup\n    total::Int\n    queuing::Int\n    running::Int\n    done::Int\n    failed::Int\n    cancelled::Int\n    eta::Millisecond\n    group_name::String\n    job_name::String\n    failed_job_names::Vector{String}\n    elapsed_times::Vector{Millisecond}\n    function JobGroup(group_name)\n        new(0, 0, 0, 0, 0, 0, Millisecond(0), group_name, \"\", String[], Millisecond[])\n    end\nend\n\nJobGroup is computed when displaying a progress meter.\n\n\n\n\n\n","category":"type"},{"location":"API/#JobSchedulers.fingerprint","page":"API","title":"JobSchedulers.fingerprint","text":"fingerprint(g::JobGroup)\nALL_JOB_GROUP_FINGERPRINT = fingerprint(ALL_JOB_GROUP)\n\nIf ALL_JOB_GROUP_FINGERPRINT is different from new fingerprint, update view.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.get_group","page":"API","title":"JobSchedulers.get_group","text":"get_group(job::Job, group_seperator = r\": *\")\n\nReturn nested_group_names::Vector{String}. \n\nEg: If job.name is \"A: B: 1232\", return [\"A\", \"A: B\", \"A: B: 1232\"]\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.progress_bar","page":"API","title":"JobSchedulers.progress_bar","text":"progress_bar(percent::Float64, width::Int = 20)\n\nReturn ::String for progress bar whose char length is width.\n\npercent: range from 0.0 - 1.0, or to be truncated.\nwidth: should be > 3. If <= 10, percentage will not show. If > 10, percentage will show.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.queue_progress","page":"API","title":"JobSchedulers.queue_progress","text":"queue_progress(;remove_tmp_files::Bool = true, kwargs...)\nqueue_progress(stdout_tmp::IO, stderr_tmp::IO;\ngroup_seperator = r\": *\", wait_second_for_new_jobs::Int = 1, loop::Bool = true, exit_num_jobs::Int = 0)\n\ngroup_seperator: delim to split (job::Job).name to group and specific job names.\nwait_second_for_new_jobs::Int: if auto_exit, and all jobs are PAST, not quiting queue_progress immediately but wait for a period. If new jobs are submitted, not quiting queue_progress.\nloop::Bool: if false, only show the current progress and exit. \nexit_num_jobs::Int: exit when queue() has less than Int number of jobs. It is useful to ignore some jobs that are always running or recurring.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.view_update","page":"API","title":"JobSchedulers.view_update","text":"view_update(h, w; row = 1, groups_shown::Vector{JobGroup} = JobGroup[], is_in_terminal::Bool = true, is_interactive = true, group_seperator_at_begining = r\"^: *\")\n\nUpdate the whole screen view.\n\n\n\n\n\n","category":"function"}]
}
