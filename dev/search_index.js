var documenterSearchIndex = {"docs":
[{"location":"changelog/#Changelog","page":"Change Log","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.13","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Docs: generate stable docs.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.12","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Pipelines v0.9, 0.10 (new), 1 (not published).\nDocs: Use Documenter.jl.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.11","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Update: Term to v2.\nFeat: Set a lower loop interval of nthreads > 2.\nFeat: Move scheduler_start() in init","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.10","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Better progress bar for visualization.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.9","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: solve_optimized_ncpu(): devision by 0 if njob == 0.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.8","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: solve_optimized_ncpu(): Find the optimized number of CPU for a job.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.7","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: style_line(): index error for special UTF characters.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.6","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: if original stdout is a file, not contaminating stdout using wait_queue(show_progress = true).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.5","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Change: remove extra blank lines after wait_queue(show_progress = true).\nFix a benign error (task switch error for sleep()).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.4","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Progress meter: wait_queue(show_progress = true).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.3","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: Pipelines v0.9: significant improvement on decision of re-run: considering file change.\nFix: pretty print of Job and Vector{Job}.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.2","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: unexpected output of scheduler_status() when SCHEDULER_TASK is not defined.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat: PrettyTables = \"0.12 - 2\" to satisfy DataFrames v1.3.5 which needs PrettyTables v1 but not v2.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.7.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Remove dependency DataFrames and change to PrettyTables. The loading time of DataFrames is high.\nFeature: now a Job is sticky to one thread (>1). JobSchedulers allocates and manuages it. The SCHEDULER_TASK is sticky to thread 1.\nFeature: queue(...) is rewritten.\nFeature: Better pretty print of Job and queue().\nFeature: New function: wait_queue() waits for all jobs in queue() become finished.\nFeature: New function: set_scheduler()\nFix: set_scheduler_max_cpu(percent::Float64): use default_ncpu() if error.\nChange: SCHEDULERUPDATESECOND to 0.05 from 0.6","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.12","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Enchance compatibility with Pipelines v0.8.5: Program has a new field called arg_forward that is used to forward user-defined inputs/outputs to specific keyword arguments of JobSchedulers.Job(::Program, ...), including name::String, user::String, ncpu::Int, mem::Int.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.11","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: running queue() when updating queue: use lock within DataFrames.DataFrame(job_queue::Vector{Job}).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.10","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Update documents.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.9","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Support Pipelines.jl v0.8.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.8","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Replace @Job with Job to run program without creating inputs::Dict and outputs::Dict. Remove @Job.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.7","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Feature: Run program without creating inputs::Dict and outputs::Dict: @Job program::Program key_value_args... Job_args.... See also @run in Pipelines.jl.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.6","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Optimize: job.dependency now accepts DONE => job, [DONE => job1.id; PAST => job2].\nOptimize: is_dependency_ok(job::Job)::Bool is rewritten: for loop when found a dep not ok, and delete previous ok deps. If dep is provided as Int, query Int for job and then replace Int with the job.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.5","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: If an app is built, SCHEDULERMAXCPU and SCHEDULERMAXMEM will be fixed to the building computer: fix by re-defining SCHEDULER_MAX_CPU and SCHEDULER_MAX_MEM in __init__().\nDebug: add debug outputs.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.4","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: scheduler_stop() cannot stop because v0.6.1 update. Now scheduler_stop does not send ^C to SCHEDULER_TASK, but a new global variable SCHEDULER_WHILE_LOOP::Bool is added to control the while loop in scheduler().\nOptimize: the package now can be precompiled: global Task cannot be precompiled, so we do not define SCHEDULER_TASK::Task when loading the package. Define it only when needed.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.3","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: scheduler_start() now wait until SCHEDULER_TASK is actually started. Previously, it returns after schedule(SCHEDULER_TASK).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.2","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compat Pipelines v0.7.0.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Robustness: scheduler() and waitforlock(): wrap sleep() within a try-catch block. If someone sends ctrl + C to sleep, scheduler wont stop.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.6.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compatibility: Pipelines v0.5.0: Job(...; dir=dir).","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.5.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Fix: programcloseio: If the current stdout/stderr is IO, restore to default stdout/stderr.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.5.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Compatibility: Pipelines v0.5.0: fixed redirection error and optimized stack trace display. Extend Base.istaskfailed to fit Pipelines and JobSchedulers packages, which will return a StackTraceVector in t.result, while Base considered it as :done. The fix checks the situation and modifies the real task status and other properties.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.4.1","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Export PAST. PAST is the super set of DONE, FAILED, CANCELLED, which means the job will not run in the future.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.4.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"If running with multi-threads Julia, SCHEDULER_TASK runs in thread 1, and other jobs spawn at other threads. Thread assignment was achieved by JobScheduler. Besides, SCHEDULER_MAX_CPU = nthreads() > 1 ? nthreads()-1 : Sys.CPU_THREADS.\nNew feature: queue(job_state::Symbol).\nUse try-finally for all locks.","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"v0.3.0","category":"page"},{"location":"changelog/","page":"Change Log","title":"Change Log","text":"Tasks run on different threads, if Julia version supports and nthreads() > 1.\nUse SpinLock.\nFix typo \"queuing\" from \"queueing\".\nNotify when a job is failed.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you need to run multiple heavy Julia tasks, it is recommended to start Julia with multi-threads.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JobSchedulers, Dates","category":"page"},{"location":"manual/#Scheduler-control","page":"Manual","title":"Scheduler control","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"scheduler_start()\n# [ Info: Scheduler starts.\n\nscheduler_status()\n# ┌ Info: Scheduler is running.\n# │   SCHEDULER_MAX_CPU = 32\n# │   SCHEDULER_MAX_MEM = 121278191616\n# │   SCHEDULER_UPDATE_SECOND = 0.05\n# │   JOB_QUEUE_MAX_LENGTH = 10000\n# └   SCHEDULER_TASK = Task (runnable) @0x00007fe205052e60\n# :running\n\nscheduler_stop()","category":"page"},{"location":"manual/#Scheduler-settings","page":"Manual","title":"Scheduler settings","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the maximum CPU that the scheduler can use. If starting Julia with multi-threads, the maximum CPU is nthreads() - 1.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_max_cpu()     # use all available CPUs\n# 32\nset_scheduler_max_cpu(4)    # use 4 CPUs\n# 4\nset_scheduler_max_cpu(0.5)  # use 50% of CPUs\n# 16","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the maximum RAM the scheduler can use:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_max_mem()             # use 80% of total memory\n# 107792089088\n\nset_scheduler_max_mem(4GB)          # use 4GB memory\nset_scheduler_max_mem(4096MB)\nset_scheduler_max_mem(4194304KB)\nset_scheduler_max_mem(4294967296B)\n# 4294967296\nset_scheduler_max_mem(0.5)          # use 50% of total memory\n# 67370055680","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the update interval of job queue:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_update_second(0.03)  # update job queue every 0.3 seconds\n# 0.03","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the maximum number of finished jobs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_max_job(10000)  # If number of finished jobs > 10000, the oldest ones will be removed.\n# 10000                       # It does not affect queuing or running jobs.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set the previous setting in one function:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler(\n    max_cpu = JobSchedulers.SCHEDULER_MAX_CPU,\n    max_mem = JobSchedulers.SCHEDULER_MAX_MEM,\n    update_second = JobSchedulers.SCHEDULER_UPDATE_SECOND,\n    max_job = JobSchedulers.JOB_QUEUE_MAX_LENGTH\n)\n# ┌ Info: Scheduler is running.\n# │   SCHEDULER_MAX_CPU = 16\n# │   SCHEDULER_MAX_MEM = 67370055680\n# │   SCHEDULER_UPDATE_SECOND = 0.03\n# │   JOB_QUEUE_MAX_LENGTH = 10000\n# └   SCHEDULER_TASK = Task (runnable) @0x00007fd239184fe0\n# :running","category":"page"},{"location":"manual/#Job-controls","page":"Manual","title":"Job controls","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"A Job is the wrapper of AbstractCmd, Function or Task:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"command_job = Job(\n    `echo command job done`    # AbstractCmd to run\n)\n\nfunction_job = Job() do  # the function should have no arguments\n    println(\"function job done\")\nend\n\ntask_job = Job(\n    @task(println(\"task job done\"))  # Task to run\n)\n\njob_with_args = Job(\n    @task(begin println(\"job_with_args done\"); \"result\" end); # Task to run\n    name = \"job with args\",               # job name.\n    user = \"me\",                # Job owner.\n    ncpu = 1,                   # Number of CPU required.\n    mem = 1KB,                  # Number of memory required (unit: TB, GB, MB, KB, B).\n    schedule_time = Second(3),  # Run after 3 seconds; can be ::DateTime or ::Period.\n    wall_time = Hour(1),        # The maximum time to run the job. (Cancel job after reaching wall time.)\n    priority = 20,              # Lower number = higher priority.\n    dependency = [              # Defer job until some jobs reach some states.\n        DONE => command_job,\n        DONE => task_job.id\n    ]\n)\n# Job:\n#   id            → 3603962603799412\n#   name          → \"job with args\"\n#   user          → \"me\"\n#   ncpu          → 1\n#   mem           → 1024\n#   schedule_time → 2022-11-18 11:35:08\n#   create_time   → 0000-01-01 00:00:00\n#   start_time    → 0000-01-01 00:00:00\n#   stop_time     → 0000-01-01 00:00:00\n#   wall_time     → 1 hour\n#   state         → :queuing\n#   priority      → 20\n#   dependency    → 2 jobs\n#   task          → Task\n#   stdout_file   → \"\"\n#   stderr_file   → \"\"\n#   _thread_id    → 0","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"dependency argument in Job(...) controls when to start a job.It is a vector with element STATE => job or STATE => job.id.STATE is one of DONE, FAILED, CANCELLED, QUEUING, RUNNING, PAST.   The first 5 states are real job states.   PAST is the super set of DONE, FAILED, CANCELLED, which means the job will not run in the future.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Submit a job to queue:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"submit!(command_job)\nsubmit!(task_job)\nsubmit!(job_with_args)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Cancel or interrupt a job:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"cancel!(command_job)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Get the returned result:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"result(job_with_args)\n# \"result\"","category":"page"},{"location":"manual/#Queue","page":"Manual","title":"Queue","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Show queue (all jobs):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue(:all)      # or:\nqueue(all=true)  # or:\nall_queue()\n# 3-element Vector{Job}:\n# ┌─────┬───────┬──────────────────┬─────────────────┬──────┬──────┬────────\n# │ Row │ state │               id │            name │ user │ ncpu │  mem  ⋯\n# ├─────┼───────┼──────────────────┼─────────────────┼──────┼──────┼────────\n# │   1 │ :done │ 3603962559801309 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   2 │ :done │ 3603962563817452 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   3 │ :done │ 3603962603799412 │ \"job with args\" │ \"me\" │    1 │ 1024  ⋯\n# └─────┴───────┴──────────────────┴─────────────────┴──────┴──────┴────────\n#                                                         11 columns omitted","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Show queue (running and queuing jobs only):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue()\n# 0-element Vector{Job}:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Show queue using a job state (QUEUING, RUNNING, DONE, FAILED, CANCELLED, or PAST):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue(DONE)\n# 3-element Vector{Job}:\n# ┌─────┬───────┬──────────────────┬─────────────────┬──────┬──────┬────────\n# │ Row │ state │               id │            name │ user │ ncpu │  mem  ⋯\n# ├─────┼───────┼──────────────────┼─────────────────┼──────┼──────┼────────\n# │   1 │ :done │ 3603962559801309 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   2 │ :done │ 3603962563817452 │              \"\" │   \"\" │    1 │    0  ⋯\n# │   3 │ :done │ 3603962603799412 │ \"job with args\" │ \"me\" │    1 │ 1024  ⋯\n# └─────┴───────┴──────────────────┴─────────────────┴──────┴──────┴────────\n#                                                         11 columns omitted","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"queue(...) and all_queue() can also used to filter job name and user. Please find out more by typing ?queue and ?all_queue in REPL.","category":"page"},{"location":"manual/#Job-query","page":"Manual","title":"Job query","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Get Job object by providing job ID.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"job_query(3603962563817452)  # or:\nqueue(3603962563817452)\n# Job:\n#   id            → 3603962563817452\n#   name          → \"\"\n#   user          → \"\"\n#   ncpu          → 1\n#   mem           → 0\n#   schedule_time → 0000-01-01 00:00:00\n#   create_time   → 2022-11-18 11:35:30\n#   start_time    → 2022-11-18 11:35:30\n#   stop_time     → 2022-11-18 11:35:30\n#   wall_time     → 1 week\n#   state         → :done\n#   priority      → 20\n#   dependency    → []\n#   task          → Task\n#   stdout_file   → \"\"\n#   stderr_file   → \"\"\n#   _thread_id    → 0","category":"page"},{"location":"manual/#Wait-for-all-jobs-and-progress-meter","page":"Manual","title":"Wait for all jobs and progress meter","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Wait for all jobs in queue() finished using wait_queue(; show_progress::Bool).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If show_progress = true, a fancy progress meter will display.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"wait_queue()\n# no output\n\nwait_queue(show_progress = true)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(Image: progress meter)","category":"page"},{"location":"manual/#Find-optimized-ncpu-that-a-Job-can-use","page":"Manual","title":"Find optimized ncpu that a Job can use","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Only available from JobSchedulers v0.7.8.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"solve_optimized_ncpu(default::Int; \n    ncpu_range::UnitRange{Int64} = 1:total_cpu, \n    njob::Int = 1, \n    total_cpu::Int = JobSchedulers.SCHEDULER_MAX_CPU, \n    side_jobs_cpu::Int = 0)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Find the optimized number of CPU for a job.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"default: default ncpu of the job.\nncpu_range: the possible ncpu range of the job.\nnjob: number of the same job.\ntotal_cpu: the total CPU that can be used by JobSchedulers.\nside_jobs_cpu: some small jobs that might be run when the job is running, so the job won't use up all of the resources and stop small tasks.","category":"page"},{"location":"manual/#Compatibility-with-Pipelines.jl","page":"Manual","title":"Compatibility with Pipelines.jl","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"[Pipelines.jl]: https://cihga39871.github.io/Pipelines.jl/dev/\t\"Pipelines.jl: A lightweight Julia package for computational pipelines and workflows.\"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can also create a Job by using Program types from Pipelines.jl:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Job(p::Program; program_kwargs..., run_kwargs..., job_kwargs...)\nJob(p::Program, inputs; run_kwargs..., job_kwargs...)\nJob(p::Program, inputs, outputs; run_kwargs..., job_kwargs...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"program_kwargs... is input and output arguments defined in p::Program.\nrun_kwargs... is keyword arguments of run(::Program; ...)\njob_kwargs... is keyword arguments of Job(::Union{Base.AbstractCmd,Task}; ...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Details can be found by typing","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using Pipelines, JobSchedulers\njulia> ?run\njulia> ?Job","category":"page"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Pipelines, JobSchedulers\n\nscheduler_start()\n\np = CmdProgram(\n    inputs = [\"IN1\", \"IN2\"],\n    outputs = \"OUT\",\n    cmd = pipeline(`echo inputs are: IN1 and IN2` & `echo outputs are: OUT`)\n)\n# CmdProgram:\n#   name             → Command Program\n#   id_file          → \n#   info_before      → auto\n#   info_after       → auto\n#   cmd_dependencies → CmdDependency[]\n#   arg_inputs       → IN1 :: Any (required)\n#                      IN2 :: Any (required)\n#   validate_inputs  → do_nothing\n#   prerequisites    → do_nothing\n#   cmd              → `echo inputs are: IN1 and IN2` & `echo outputs are: OUT`\n#   infer_outputs    → do_nothing\n#   arg_outputs      → OUT :: Any (required)\n#   validate_outputs → do_nothing\n#   wrap_up          → do_nothing\n#   arg_forward      → Pair{String, Symbol}[]\n\n\n### native Pipelines.jl method to run the program\nrun(p, IN1 = `in1`, IN2 = 2, OUT = \"out\", touch_run_id_file = false) # touch_run_id_file = false means do not create a file which indicates the job is done and avoids re-run.\n\n# inputs are: in1 and in2\n# outputs are: out\n# (true, Dict(\"OUT\" => \"out\"))\n\n### run the program by submitting to JobSchedulers.jl\nprogram_job = Job(p, IN1 = `in1`, IN2 = 2, OUT = \"out\", touch_run_id_file = false)\n# Job:\n#   id            → 3603980229784158\n#   name          → \"Command Program\"\n#   user          → \"\"\n#   ncpu          → 1\n#   mem           → 0\n#   schedule_time → 0000-01-01 00:00:00\n#   create_time   → 0000-01-01 00:00:00\n#   start_time    → 0000-01-01 00:00:00\n#   stop_time     → 0000-01-01 00:00:00\n#   wall_time     → 1 week\n#   state         → :queuing\n#   priority      → 20\n#   dependency    → []\n#   task          → Task\n#   stdout_file   → \"\"\n#   stderr_file   → \"\"\n#   _thread_id    → 0\n\nsubmit!(program_job)\n# inputs are: in1 and 2\n# outputs are: out\n\n# get the returned result\nresult(program_job)\n# (true, Dict(\"OUT\" => \"out\"))","category":"page"},{"location":"manual/#Backup","page":"Manual","title":"Backup","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Set backup file:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_backup(\"/path/to/backup/file\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"JobSchedulers writes to the backup file at exit. If the file exists, scheduler settings and job queue will be recovered from it automatically. Recovered jobs are just for query, not run-able.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Stop backup and delete_old backup:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"set_scheduler_backup(delete_old=true)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Backup immediately:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"backup()","category":"page"},{"location":"#JobSchedulers.jl","page":"Home","title":"JobSchedulers.jl","text":"","category":"section"},{"location":"#Why-JobScheduler?","page":"Home","title":"Why JobScheduler?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We may find different tasks or programs use different CPU and memory. Some can run simultaneously, but some have to run sequentially. JobScheduler is stable, useful and powerful for task queuing and workload management. ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Job and task scheduler.\nLocal workload manager.\nSupport CPU, memory, run time management.\nSupport running a job at specific time, or a period after creating (schedule).\nSupport deferring a job until specific jobs reach specific states (dependency).\nSupport automatic backup and reload.\nFancy progress meter in terminal.\n(Image: progress meter)","category":"page"},{"location":"#Future-development","page":"Home","title":"Future development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support command-line scheduler by using DaemonMode.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JobSchedulers.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add JobSchedulers","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JobSchedulers","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Scheduler-Control","page":"API","title":"Scheduler Control","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"scheduler_status\nscheduler_start\nscheduler_stop","category":"page"},{"location":"API/#JobSchedulers.scheduler_status","page":"API","title":"JobSchedulers.scheduler_status","text":"scheduler_status() :: Symbol\n\nPrint the settings and status of job scheduler. Return :not_running or :running.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.scheduler_start","page":"API","title":"JobSchedulers.scheduler_start","text":"scheduler_start()\n\nStart the job scheduler.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.scheduler_stop","page":"API","title":"JobSchedulers.scheduler_stop","text":"scheduler_stop()\n\nStop the job scheduler.\n\n\n\n\n\n","category":"function"},{"location":"API/#Scheduler-Settings","page":"API","title":"Scheduler Settings","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"set_scheduler\nset_scheduler_max_cpu\nset_scheduler_max_mem\nset_scheduler_update_second\nset_scheduler_max_job","category":"page"},{"location":"API/#JobSchedulers.set_scheduler","page":"API","title":"JobSchedulers.set_scheduler","text":"set_scheduler(;\n    max_cpu::Union{Int,Float64} = JobSchedulers.SCHEDULER_MAX_CPU,\n    max_mem::Union{Int,Float64} = JobSchedulers.SCHEDULER_MAX_MEM,\n    max_job::Int = JobSchedulers.JOB_QUEUE_MAX_LENGTH,\n    update_second = JobSchedulers.SCHEDULER_UPDATE_SECOND\n)\n\nSee details: set_scheduler_max_cpu,  set_scheduler_max_mem,  set_scheduler_max_job,  set_scheduler_update_second \n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_max_cpu","page":"API","title":"JobSchedulers.set_scheduler_max_cpu","text":"set_scheduler_max_cpu(ncpu::Int = default_ncpu())\nset_scheduler_max_cpu(percent::Float64)\n\nSet the maximum CPU (thread) the scheduler can use. If starting Julia with multi-threads, the maximum CPU is nthreads() - 1.\n\nExample\n\nset_scheduler_max_cpu()     # use all available CPUs\nset_scheduler_max_cpu(4)    # use 4 CPUs\nset_scheduler_max_cpu(0.5)  # use 50% of CPUs\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_max_mem","page":"API","title":"JobSchedulers.set_scheduler_max_mem","text":"set_scheduler_max_mem(mem::Int = default_mem())\nset_scheduler_max_mem(percent::Float64)\n\nSet the maximum RAM the scheduler can use.\n\nExample\n\nset_scheduler_max_mem()             # use 80% of total memory\n\nset_scheduler_max_mem(4GB)          # use 4GB memory\nset_scheduler_max_mem(4096MB)\nset_scheduler_max_mem(4194304KB)\nset_scheduler_max_mem(4294967296B)\n\nset_scheduler_max_mem(0.5)          # use 50% of total memory\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_update_second","page":"API","title":"JobSchedulers.set_scheduler_update_second","text":"set_scheduler_update_second(s::Float64 = 0.6)\n\nSet the update interval of scheduler.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.set_scheduler_max_job","page":"API","title":"JobSchedulers.set_scheduler_max_job","text":"set_scheduler_max_job(n_finished_jobs::Int = 10000)\n\nSet the number of finished jobs.\n\n\n\n\n\n","category":"function"},{"location":"API/#Job","page":"API","title":"Job","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Job\nsubmit!\ncancel!\nresult","category":"page"},{"location":"API/#JobSchedulers.Job","page":"API","title":"JobSchedulers.Job","text":"Job(command::Base.AbstractCmd; stdout=nothing, stderr=nothing, append::Bool=false, kwargs...)\nJob(f::Function; kwargs...)\nJob(task::Task; kwargs...)\n\nArguments\n\ncommand::Base.AbstractCmd: the command to run.\nf::Function: the function to run without any arguments, like f().\ntask::Task: the task to run. Eg: @task(1+1).\n\nCommon Keyword Arguments (kwargs...)\n\nname::String = \"\": job name.\nuser::String = \"\": user that job belongs to.\nncpu::Int64 = 1: number of CPU this job is about to use.\nmem::Int64 = 0: number of memory this job is about to use (supports TB, GB, MB, KB, B=1).\nschedule_time::Union{DateTime,Period} = DateTime(0): The expected time to run.\ndependency: defer job until specified jobs reach specified state (QUEUING, RUNNING, DONE, FAILED, CANCELLED, PAST). PAST is the super set of DONE, FAILED, CANCELLED, which means the job will not run in the future. Eg: DONE => job, [DONE => job1; PAST => job2].\n\nTo be compatible with old versions, you can also use job id (Int): [DONE => job.id].\n\nwall_time::Period = Week(1): wall clock time limit.\npriority::Int = 20: lower means higher priority.\n\nExperimental Keyword Arguments - Output Redirection:\n\nstdout=nothing: redirect stdout to the file.\nstderr=nothing: redirect stderr to the file.\nappend::Bool=false: append the stdout or stderr or not.\n\nnote: Note\nRedirecting in Julia are not thread safe, so unexpected redirection might be happen if you are running programs in different Tasks simultaneously (multi-threading).\n\n\n\n\n\n","category":"type"},{"location":"API/#JobSchedulers.submit!","page":"API","title":"JobSchedulers.submit!","text":"submit!(job::Job)\n\nSubmit the job. If job.create_time == 0000-01-01T00:00:00 (default), it will change to the time of submission.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.cancel!","page":"API","title":"JobSchedulers.cancel!","text":"cancel!(job::Job)\n\nCancel job, stop queuing or running.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.result","page":"API","title":"JobSchedulers.result","text":"result(job::Job)\n\nReturn the result of job. If the job is not done, a warning message will also show.\n\n\n\n\n\n","category":"function"},{"location":"API/#Queue","page":"API","title":"Queue","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"queue\nall_queue\njob_query","category":"page"},{"location":"API/#JobSchedulers.queue","page":"API","title":"JobSchedulers.queue","text":"queue(; all::Bool = false)    -> Vector{Job}\nqueue(state::Symbol )         -> Vector{Job}\nqueue(needle)                 -> Vector{Job}\nqueue(state::Symbol , needle) -> Vector{Job}\nqueue(needle, state::Symbol ) -> Vector{Job}\nqueue(id::Int)                -> Job\n\nall::Bool: if true, get all jobs. if false, get only running and queuing jobs.\nstate::Symbol: get jobs with a specific state, including :all, QUEUING, RUNNING, DONE, FAILED, CANCELLED, PAST.\nPAST is the superset of DONE, FAILED, CANCELLED.\nneedle::Union{AbstractString,AbstractPattern,AbstractChar}: get jobs if they contain needle in their name or user.\nid::Int: get the job with the specific id.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.all_queue","page":"API","title":"JobSchedulers.all_queue","text":"all_queue()\nall_queue(id::Int64)\nall_queue(state::Symbol)\nall_queue(needle::Union{AbstractString,AbstractPattern,AbstractChar})\n\nstate::Symbol: get jobs with a specific state, including :all, QUEUING, RUNNING, DONE, FAILED, CANCELLED, PAST.\nPAST is the superset of DONE, FAILED, CANCELLED.\nneedle::Union{AbstractString,AbstractPattern,AbstractChar}: get jobs if they contain needle in their name or user.\nid::Int: get the job with the specific id.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.job_query","page":"API","title":"JobSchedulers.job_query","text":"job_query_by_id(id::Int64)\n\nSearch job by job.id in the queue.\n\nReturn job::Job if found, nothing if not found.\n\n\n\n\n\n","category":"function"},{"location":"API/#Wait-For-All-Jobs","page":"API","title":"Wait For All Jobs","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"wait_queue","category":"page"},{"location":"API/#JobSchedulers.wait_queue","page":"API","title":"JobSchedulers.wait_queue","text":"wait_queue(;show_progress = false)\n\nWait for all jobs in queue() become finished.\n\nshow_progress = true, job progress will show.\n\nSee also: queue_progress.\n\n\n\n\n\n","category":"function"},{"location":"API/#Optimize-CPU-Usage","page":"API","title":"Optimize CPU Usage","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"solve_optimized_ncpu","category":"page"},{"location":"API/#JobSchedulers.solve_optimized_ncpu","page":"API","title":"JobSchedulers.solve_optimized_ncpu","text":"solve_optimized_ncpu(default::Int; \n    ncpu_range::UnitRange{Int64} = 1:total_cpu, \n    njob::Int = 1, \n    total_cpu::Int = JobSchedulers.SCHEDULER_MAX_CPU, \n    side_jobs_cpu::Int = 0)\n\nFind the optimized number of CPU for a job.\n\ndefault: default ncpu of the job.\nncpu_range: the possible ncpu range of the job.\nnjob: number of the same job.\ntotal_cpu: the total CPU that can be used by JobSchedulers.\nside_jobs_cpu: some small jobs that might be run when the job is running, so the job won't use up all of the resources and stop small tasks.\n\n\n\n\n\n","category":"function"},{"location":"API/#Backup","page":"API","title":"Backup","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"set_scheduler_backup\nbackup","category":"page"},{"location":"API/#JobSchedulers.set_scheduler_backup","page":"API","title":"JobSchedulers.set_scheduler_backup","text":"set_scheduler_backup(\n    filepath::AbstractString = \"\";\n    migrate::Bool = false,\n    delete_old::Bool = false,\n    recover_settings::Bool = true,\n    recover_queue::Bool = true\n)\n\nSet the backup file of job scheduler.\n\nIf filepath was set to \"\", stop backup at exit.\n\nIf filepath was set to an existing file, recover_settings or recover_queue from filepath immediately.\n\nIf filepath was set to a new file, the backup file will be created at exit.\n\nIf migrate=true and the old JobSchedulers.SCHEDULER_BACKUP_FILE exists, the old backup file will be recovered before recovering from filepath.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.backup","page":"API","title":"JobSchedulers.backup","text":"backup()\n\nManually backup job scheduler settings and queues. The function is automatically triggered at exit.\n\n\n\n\n\n","category":"function"},{"location":"API/#Progress-Meter","page":"API","title":"Progress Meter","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"note: Note\nTo display a progress meter, please use wait_queue(show_progress = true).","category":"page"},{"location":"API/","page":"API","title":"API","text":"JobSchedulers.JobGroup\nJobSchedulers.fingerprint\nJobSchedulers.get_group\nJobSchedulers.progress_bar\nJobSchedulers.queue_progress\nJobSchedulers.view_update","category":"page"},{"location":"API/#JobSchedulers.JobGroup","page":"API","title":"JobSchedulers.JobGroup","text":"mutable struct JobGroup\n    total::Int\n    queuing::Int\n    running::Int\n    done::Int\n    failed::Int\n    cancelled::Int\n    eta::Millisecond\n    group_name::String\n    job_name::String\n    failed_job_names::Vector{String}\n    elapsed_times::Vector{Millisecond}\n    function JobGroup(group_name)\n        new(0, 0, 0, 0, 0, 0, Millisecond(0), group_name, \"\", String[], Millisecond[])\n    end\nend\n\nJobGroup is computed when displaying a progress meter.\n\n\n\n\n\n","category":"type"},{"location":"API/#JobSchedulers.fingerprint","page":"API","title":"JobSchedulers.fingerprint","text":"fingerprint(g::JobGroup)\nALL_JOB_GROUP_FINGERPRINT = fingerprint(ALL_JOB_GROUP)\n\nIf ALL_JOB_GROUP_FINGERPRINT is different from new fingerprint, update view.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.get_group","page":"API","title":"JobSchedulers.get_group","text":"get_group(job::Job, group_seperator = r\": *\")\n\nReturn nested_group_names::Vector{String}. \n\nEg: If job.name is \"A: B: 1232\", return [\"A\", \"A: B\", \"A: B: 1232\"]\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.progress_bar","page":"API","title":"JobSchedulers.progress_bar","text":"progress_bar(percent::Float64, width::Int = 20)\n\nReturn ::String for progress bar whose char length is width.\n\npercent: range from 0.0 - 1.0, or to be truncated.\nwidth: should be > 3. If <= 10, percentage will not show. If > 10, percentage will show.\n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.queue_progress","page":"API","title":"JobSchedulers.queue_progress","text":"queue_progress(;remove_tmp_files::Bool = true, kwargs...)\nqueue_progress(stdout_tmp::IO, stderr_tmp::IO;\ngroup_seperator = r\": *\", wait_second_for_new_jobs::Int = 1, loop::Bool = true)\n\ngroup_seperator: delim to split (job::Job).name to group and specific job names.\nwait_second_for_new_jobs: if auto_exit, and all jobs are PAST, not quiting queue_progress immediately but wait for a period. If new jobs are submitted, not quiting queue_progress.\nloop: if false, only show the current progress and exit. \n\n\n\n\n\n","category":"function"},{"location":"API/#JobSchedulers.view_update","page":"API","title":"JobSchedulers.view_update","text":"view_update(h, w; row = 1, groups_shown::Vector{JobGroup} = JobGroup[], is_in_terminal::Bool = true, is_interactive = true, group_seperator_at_begining = r\"^: *\")\n\nUpdate the whole screen view.\n\n\n\n\n\n","category":"function"}]
}
